# ფუნქციები - Functions

კოდის წერისას ხშირად გვაქვს მომენტი, როდესაც ერთი სახის ფუნქციონალი ბევრჯერ გვჭირდება. ასეთ დროს ერთი და იმავე კოდის გამეორება საკმაოდ ცუდი პრაქტიკაა, რადგან არღვევს DRY პრინციპს (Don't repeat yourself). კიდევ არის მომენტები, როდესაც რაღაც ფუნქციონალმა უნდა იმუშაოს ნებისმიერ კონკრეტულ შემთხვევაში, ანუ ასეთი სახის კოდს უნდა ჰქონდეს რაღაც კონკრეტული input და შესაბამისი output ერთხელ ჩაწერილი ზოგადი კოდის ხარჯზე. ასეთ დროს კი ვიყენებთ ფუნქციებს.

```js
for (let i = 1; i <= 10; i++) {
  console.log(i);
}

for (let i = 1; i <= 10; i++) {
  console.log(i);
}

for (let i = 1; i <= 10; i++) {
  console.log(i);
}

for (let i = 1; i <= 10; i++) {
  console.log(i);
}
// bad practice
```

## სინტაქსი

ფუნქციის ჩაწერისას ჯერ ვწერთ "function" keyword-ს, რათა პროგრამას ვუთხრათ რომ ფუნქციის შექმნას ვაპირებთ. შემდგომ იწერება ფუნქციის სახელი camelCase მიდგომით, მერე მრგვალი ფრჩხილები და ამ ფუნქციის შიგთავსს კი ვწერთ ფიგურულ ფრჩხილებში. ფუნცქციის გამოსაძახებლად ვიყენებთ მისივე სახელს და შემდეგ მრგვალ ფრჩხილებსაც ვუწერთ. ზუსტად მრგვალი ფრჩხილები იძახებს ფუნქციას, მის გარეშე პროგრამაში არაფერი მოხდება, უბრალოდ ფუნქცია გვექნება, რომელიც დარჩება გამოძხების გარეშე.

```js
function printNumbers() {
  for (let i = 1; i <= 10; i++) {
    console.log(i);
  }
}

printNumbers();
printNumbers();
printNumbers();
```

## return

ფუნქციაში რაიმე სახის კალკულაციების შედეგად მიღებული პასუხი შეგვიძლია დავაბრუნოთ კიდეც. ანუ ფუქნციას რომ გამოვიძახებთ, მის ადგილას ჩაიწერება ამ ფუნქციის მიერ დაბრუნებული ანუ დარეთარნებული მნიშვნელობა. მნიშვნელობის დასაბრუნებლად ვიყენებთ return-ს:

```js
function sum() {
  let x = 10;
  let y = 5;
  let sum = x + y;
  return sum;
}

console.log(sum()); // 15
```

უბრალოდ sum() რომ დაგვეწერა, არაფერი გამოკონსოლდებოდა, რადგან ფუნქციის გამოძახების ადგილას ჩაჯდებოდა 15 და უბრალოდ კომპიუტერის მეხსიერებაში შეინახებოდა. გამოსაკონსოლებლად კი ფუნქციის გამოძხება console.log() ფუნქციაში უნდა ჩავსვათ.
ზუსტადაც რომ console.log-ის შემდეგ დაწერილი მრგვალი ფრჩხილები იძახებს console.log ფუნქციას, რომელიც ჯავასკრფიტშია ჩაშენებული. ანუ ვიღაცამ ადრე დაწერა ეს ფუქნცია და ახლა მას მარტივად ვიყენებთ, რათა რაიმე მნიშვნელობის გამოსაპრინტად იგივე კოდი ბევრჯერ არ ვწეროთ, რაც გამოყენებული არის console.log ფუქნციაში.

## arguments & parameters | არგუმენტები და პარამეტრები

გამოდის რომ ფუნქციაში return გვეხმარება მნიშვნელობის დასაბრუნებლად, ანუ ეს ნაწილი output არის. input-ს ანუ ფუნქციაში შესულ მნიშვნეელობას რაც შეეხება, ხორციელდება ქარგუმენტებითა და პარამეტრებით. ფუნქციის გამოძხებისას მრგვალ ფრჩხილებში გადავცემთ არგუმენტს, ანუ რაიმე კონკრეტულ მნიშვნელობას, რაც გვინდა რომ ფუქნციამ დაამუშაოს. ამ მნიშვნელობას რაიმე ცვლადში შენახვა ხომ უნდა, ხოდა ზუსტად მაგისთვის გამოიყენება პარამეტრები, რომლებიც იწერება ფუნქციის შექმნისას მრგვალ ფრჩხილებში.

```js
function square(x) {
  return x * x;
}

square(5); // 25
square(10); // 100
square(3); // 9
```

ეს ფუნქცია იღებს პარამეტრად რაიმე რიცხვს და აბრუნებს ამ რიცხვის კვადრატს. თვითონ ფუქნციაში კოდი ზოგადადაა გაწერილი, პარამეტრს ვიყენებთ საბოლოო პასუხის მისაღებად, ხოლო კონკრეტული მნიშვნელობები ფუნქციას გადაეცემა არგუმენტის სახით.

## default parameters

როდესაც ფუქნციას არგუმენტად არაფერს გადავცემთ, ამ დროს პარამეტრი დეფოლტად (default-ად) იღებს undefined მნიშვნელობას. ეს იგივეა, რომ ცვლადი უბრალოდ შევქმნათ და მნიშვნელობა არ მივანიჭოთ, ასეთ დროსაც undefined ანუ განუსაზღვრელი იქნება ცვლადის მნიშვნელობა. მსგავს სიტუაციებში, როდესაც ფუნქციას შესაძლოა არგუმენტი არ გადაეცეს, ვიყენებთ default parameter-ს. თუ არგუმენტი არ იქნა გადაწოდებული ფუქნციის გამოძახებისას, პარამეტრი მიიღებს იმ დეფოლტ მნიშვნელობას, რომელსაც მას განვუსაზღვრავთ მრგვალ ფრჩხილებში:

```js
function greet(name) {
  if (name === undefined) {
    return "hi, უცნობო";
  }
  return "hi, " + name;
}

console.log(greet());
```

ასე ჩაწერა და პარამეტრის undefined-ისთვის გატოლება აღარ გვჭირდება, უკეთესი იქნება, რომ ჩავწეროთ ასე:

```js
function greet(name = "უცნობო") {
  return "hi, " + name;
}

console.log(greet());
```

## bindings and scopes

მარტივად რომ ვთქვათ, ჯავასკრიფტში binding არის რაიმე მნიშვნელობის კონკრეტული ცვლადისთვის მიკავშირება კონკრეტულ scope-ში ანუ ამ ცვლადისთვის საარსებო გარემოში.

ქვევით მოცემულ მაგალითში x ცვლადის binding გლობალურ გარემოში ანუ global scope-შია შექმნილი და მისი გამოყენება ყველგან შეგვიძლია.
რაც შეეხება y ცვლადს, მას მხოლოდ if ბლოკის შიგნით გამოვიყენებთ, მის გარეთ მიუწვდომელი იქნება. თუმცა var-ით შექმნილ z ცვლადზე წვდომა if ბლოკის გარეთ შეგვიძლია რომ მოვიპოვოთ.
თუმცა, თუ var, let ან const-ით შევქმნით ცვლადს ფუქნციის scope-ში, მას ფუქნციის გარეთ ვეღარ მივწვდებით. ანუ გამოდის, რომ ცვლადებზე წვდომა შეგვიძლია შიგნიდან გარეთ მაგრამ არა გარედან შიგნით:

```js
let x = 10; // global
if (true) {
  let y = 20; // local to block
  var z = 30; // also global
}
console.log(y); // error
```

## nested scopes

შესაძლებელი ჩანესტილი ანუ ერთმანეთში ჩასმული რამდენიმე scope გვქონდეს:

```js
function hummus(factor) {
  function ingredient(amount, unit, name) {
    let ingredientAmount = amount * factor;
    if (ingredientAmount > 1) {
      unit += "s";
    }
    console.log(`${ingredientAmount} ${unit} ${name}`);
  }
  ingredient(1, "can", "chickpeas");
  ingredient(0.25, "cup", "tahini");
  ingredient(0.25, "cup", "lemon juice");
  ingredient(1, "clove", "garlic");
  ingredient(2, "tablespoon", "olive oil");
  ingredient(0.5, "teaspoon", "cumin");
}

hummus(3);
```

ამ მაგალითში ingredient ფუქნციის scope-ში ვიყენებთ მის გარეთ scope-ში არსებულ პარამეტრს - factor. თუმცა, პირიქით არ შეგვიძლია, ანუ არ შეგვიძლია hummus ფუნქციის scope-ში წვდომა მოვიპოვოთ ingredient ფუნქციის scope-ში შექმნილ ცვლადს - ingredientAmount.

## ფუნქციის ჩაწერის გზები

არსებობს ფუნქციის ჩაწერის სამი გზა

1. function declaration - ფუნქციის დეკლარაცია:

```js
function square(x) {
  return x * x;
}
```

2. function expression - ფუნქციის გამოსახულება:

```js
const square = function (x) {
  return x * x;
};
```

ასეთ ფუნქციებს სახელი არ გააჩნიათ, ანუ ანონიმური ფუნქციები არიან, ამიტომ მათ ცვლადში ვინახავთ. გამოძახების წესები და არგუმენტებისა და პარამეტრების ურთიერთობა იგივეა.

3. arrow function - ისრიანი ფუნქცია:

```js
const square = (x) => x * x;
```

ისრიანი ფუნქციების ჩაწერისას თუ ფუნქციონალი მოკლეა, ანუ ერთხაზიანია, მაშინ return-ის და ფიგურული ფრჩხილების ჩაწერა საჭირო არაა, რადგან ისედაც იგულისხმებიან. თუმცა. თუ რამდენიმეხაზიანი კოდის გვაქვს, ორივეს დაწერა აუცილებელია:

```js
const square = (x) => {
  console.log("square of number x");
  return x * x;
};
```

## hoisting

hoisting არის მოვლენა, როცა ფუნქციის დეკლარაციები(მხოლოდ ფუნქციის დეკლარაციები, სხვა გზით შექმნილი ფუნქციები არა) პროგრამის გაშვებისას ადიან პროგრამის თავში, რაც იმის საშუალებას გვაძლევს, რომ ფუნქცია ჯერ გამოვიძახოთ და შემდეგ შევქმნათ:

```js
square(5);

function square(x) {
  return x * x;
}
```

hoisting ასევე მოქმედებს var-ით შექმნილ ცვლადებზე, უბრალოდ undefined მნიშვნელობა ექნება ასეთ ცვლადს. ასეთ ჩანაწერს რაიმე პრაქტიკული დანიშნულება არ აქვს, თან var-ს ისედაც არ ვიყენებთ:

```js
console.log(number); // undefined
var number = 5;
```

## ფუნქციები, რომლებიც ლექციაზე გამოვიყენებთ

1. Math.floor() - ამრგვალებს რიცხვს ქვედა უახლოეს მთელ რიცხვამდე:
   p.s. floor იატაკს ნიშნავს და მაგით დაიმახსოვრეთ.

```js
Math.floor(10.5); // 10;
Math.floor(10.1); // 10;
Math.floor(10.99); // 10;
```

2. Math.ceil() - ამრგვალებს რიცხვს ზედა უახლოეს მთელ რიცხვამდე:
   p.s. ceil ჭერს ნიშნავს და მაგით დაიმახსოვრეთ.

```js
Math.floor(10.5); // 11;
Math.floor(10.1); // 11;
Math.floor(10.99); // 11;
```

3. Math.round() - ამრგვალებს რიცხვებს ჩვეულებრივად მათემატიკური წესების მიხედვით, ანუ იმ უახლოეს მთელ რიცხვამდე, რომელთანაც უფრო ახლოა ათწილადი რიცხვი:

```js
Math.floor(10.5); // 11;
Math.floor(10.1); // 10;
Math.floor(10.99); // 11;
```

4. Math.random() - აგენერირებს პროგრამის თითოეულ გაშვებაზე რანდომულ ათწილად რიცხვს 0-დან 1-მდე (0 შეიძლება იყოს, მაგრამ არასდროს იქნება 1)

```js
Math.random(); // 0.7760849515708645
Math.random(); // 0.1957932386611887
Math.random(); // 0.468724712722836
Math.random(); // 0.166946510995454
```

თუ გვინდა, რომ მაგალითად რანდომული მთელი რიცხვი დავაგენერიროთ 0-დან 100-მდე, მაშინ Math.random()-ს გავამრავლებთ 100-ზე, რადგან ბოლო შუალედი 100-ჯერ მეტია და დავამრგვალებთ ქვედა უახლოეს მთელ რიცხვამდე Math.floor()-ის გამოყენებით:

```js
const randomNumber = Math.floor(Math.random() * 100);
```

ასეთ შემთხვევაში პროგრამის თითოეულ გაშვებაზე დაგენერირდება რანდომული რიცხვი 0-დან 100-მდე (0 შეიძლება იყოს, მაგრამ 100 არასდროს იქნება, რადგან თავად Math.random()-ც არ იქნება 1 არასდროს)
