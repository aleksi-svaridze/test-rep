# Data Structures: Objects and Arrays

მონაცემთა სტრუქტურები JavaScript-ში გამოიყენება მონაცემების ეფექტურად შენახვისა და მართვისთვის. როდესაც გვჭირდება გარკვეული რაოდენობის ინფორმაციის შენახვა, რათქმაუნდა იმდენ ცვლადს არ გამოვიყენებთ რამდენი მნიშვნელობაც გვაქვს. ამის მაგივრად, ყველა ამ მნიშვნელობას მოვათავსებთ რომელიმე მონაცემთა სტრუქტურაში

## Arrays - მასივები

მასივები JavaScript-ში წარმოადგენს მონაცემთა სტრუქტურას, რომელიც საშუალებას გვაძლევს ერთ ცვლადში სხვადასხვა მნიშვნელობების ჩამონათვალი შევინახოთ. მასივებში მონაცემები ორგანიზებულია ინდექსების მიხედვით, სადაც თითოეულ ელემენტს აქვს თავისი უნიკალური პოზიცია, დაწყებული 0-დან. მაგალითად:

```js
let listOfNumbers = [1, 2, 3, 4, 5];
let listOfValues = [1, 2, 3, 4, 5, "ალგოუნი", false, undefined, null, Infinity];

console.log(listOfNumbers[0]); // 1
console.log(listOfNumbers[3]); // 4
console.log(listOfNumbers[4]); // 5
```

- listOfNumbers მასივი შეიცავს რიცხვებს და თითოეულ ელემენტს აქვს უნიკალური ინდექსი. მაგალითად, listOfNumbers[0] აბრუნებს 1-ს, რადგან ის მდებარეობს ნულოვან ინდექსზე.

- listOfValues მასივში შესაძლებელია სხვადასხვა ტიპის მონაცემების შენახვა, როგორიცაა რიცხვები, ტექსტები, ბულეანები და სხვა მნიშვნელობები.

## length property

მასივებში ერთ-ერთი ყველაზე გამოყენებადი თვისება არის length, რომელიც გვიჩვენებს მასივში ელემენტების რაოდენობას. ეს თვისება ავტომატურად განახლდება მასივში ახალი ელემენტების დამატების ან წაშლის შემთხვევაში.

```js
let listOfNumbers = [1, 2, 3, 4, 5];

console.log(listOfNumbers.length); // 5
```

ამ მაგალითში, მასივი listOfNumbers შეიცავს 5 ელემენტს, შესაბამისად listOfNumbers.length აბრუნებს მნიშვნელობას 5.

length თვისება ასევე გამოიყენება მასივის ბოლომდე გადავლაში(დალუპვაში, რაც კონსპექტის ბოლოსაა ახსნილი), ან როდესაც გვინდა შევამოწმოთ, თუ რამდენი ელემენტი გვაქვს მასივში.

## მეთოდები

როგორც უკვე ვთქვით, length არის მასივისა და სტრინგის property ანუ თვისება, ანუ ის გვეხმარება მოცემულ მნიშვნელობებზე დამატებითი ინფორმაციის მოპოვებაში. როდესაც ფროფერთი ფუქნციაა, მაშინ ასეთ ფროფერთებს მეთოდები ეწოდებათ. მაგალითად trim(). ფროფერთი იმიტომაა, რომ მას წერტილით ვწვდებით, ფუნქციაცაა, რადგან ფრჩხილებით ვიძახებთ, ანუ გამოდის, რომ მეთოდია.

## Array Methods

JavaScript-ში მასივებს აქვთ მრავალი მეთოდი, რომლებიც საშუალებას გვაძლევს მოვახდინოთ მათი მენეჯმენტი და მოდიფიკაცია. ქვემოთ განხილულია რამდენიმე ძირითადი მეთოდი:

1. push() - მასივის ბოლოში ახალი ელემენტის დამატება და მისი დაბრუნება.
2. pop() - მასივის ბოლო ელემენტის წაშლა და მისი დაბრუნება.
3. includes() - ამოწმებს, შეიცავს თუ არა მასივი მითითებულ მნიშვნელობას და აბრუნებს true-ს ან false-ს.

მაგალითად:

```js
let sequence = [1, 2, 3];
sequence.push(4);
sequence.push(5);
console.log(sequence);
// → [1, 2, 3, 4, 5]

console.log(sequence.pop());
// → 5

console.log(sequence);
// → [1, 2, 3, 4]

console.log(sequence.includes(4)); // true
```

- push(4) და push(5) ამატებს ელემენტებს მასივის ბოლოში.
- pop() შლის მასივის ბოლო ელემენტს და აბრუნებს მას. ამ შემთხვევაში, ის შლის რიცხვ 5-ს.
- includes(4) ამოწმებს, შეიცავს თუ არა მასივი რიცხვ 4-ს, და აბრუნებს true-ს, რადგან 4 არის მასივში.

ეს მეთოდები მასივებთან მუშაობას უფრო მოქნილს და ეფექტურს ხდის.

## Objects

ობიექტები JavaScript-ში მონაცემთა სტრუქტურებია, რომლებიც გვაძლევს საშუალებას შევინახოთ მონაცემები key-value (გასაღები-მნიშვნელობა) წყვილების სახით. ობიექტის თითოეულ თვისებას (property-ის) შეუძლია ჰქონდეს ნებისმიერი ტიპის მნიშვნელობა, მათ შორის, სხვა ობიექტები ან მასივები.

ობიექტებს ვიყენებთ მაშინ, როდესაც მნიშვნელობებს აქვთ რაიმე კავშირი თავიანთ ლოგიკურ მნიშვნელობასთან. მაგალითად, რომ გქონდეს სახელი, გვარი, ასაკი, პროფესია და ა.შ., ამ ყველაფერს მასივში ვერ ჩავყრით, რადგან ლოგიკურად ერთი და იმავე შინაარსის მატარებლები არ არიან. მასივების მაგივრად ვიყენებთ ობიექტებს, რადგან ობიექტებში გვაქვს key-value წყვილები.

```js
let person = {
  name: "temo",
  age: 19,
  hobby: ["swimming", "reading", "having fun with friends"],
};

person.profession = "programmer/mentor";

console.log(person.name); // "temo"
```

აქ ობიექტი person შეიცავს შემდეგ თვისებებს:

- name - შენახულია სახელი.
- age - ასაკი.
- hobby - მასივი, რომელიც მოიცავს ინტერესებს.

შემდგომ, ობიექტს ვამატებთ ახალ თვისებას profession, რაც საშუალებას გვაძლევს დინამიკურად დავამატოთ ან შევცვალოთ ობიექტის თვისებები.

person.name ახორციელებს ობიექტის name თვისების წვდომას და აბრუნებს "temo".

ობიექტები გამოიყენება, როდესაც საჭიროა მონაცემების ორგანიზება და მათზე სხვადასხვა ოპერაციების შესრულება.

## ობიექტის თვისებების შემოწმება

JavaScript-ში ობიექტების თვისებების არსებობის შესამოწმებლად ორი ძირითადი მეთოდი გამოიყენება:

1. in ოპერატორი - ამოწმებს, არსებობს თუ არა მითითებული თვისება (property) ობიექტში, და აბრუნებს true ან false.
2. hasOwnProperty() მეთოდი - ამოწმებს, გააჩნია თუ არა ობიექტს კონკრეტული თვისება უშუალოდ და არა მემკვიდრეობით. (მემკვიდრეობით რას ნიშნავს რა რა მცირე განსხვავებაა ამ ორს შორის, გავარჩევთ შემდეგ კვირებში)

```js
let person = {
  name: "temo",
  age: 19,
  hobby: ["swimming", "reading", "having fun with friends"],
};

console.log("name" in person); // true
console.log(person.hasOwnProperty("name")); // true

console.log("car" in person); // false
console.log(person.hasOwnProperty("car")); // false
```

- "name" in person ამოწმებს, აქვს თუ არა ობიექტს person სახელწოდების თვისება და აბრუნებს true, რადგან ეს თვისება არსებობს.
- person.hasOwnProperty("name") ასევე აბრუნებს true-ს, რადგან name არის person-ის უშუალო თვისება.
- "car" in person და person.hasOwnProperty("car") აბრუნებენ false-ს, რადგან ობიექტს არ გააჩნია car თვისება.

ამ მეთოდების დახმარებით მარტივად შეგვიძლია გავარკვიოთ, არსებობს თუ არა გარკვეული თვისებები ობიექტში.

## მუტაცია (Mutability)

JavaScript-ში მონაცემთა ტიპები იყოფა ორ კატეგორიად: მუტაციური და არამუტაციური.

- არამუტაციური (Immutable) - მონაცემთა ტიპები(პრიმიტიული), რომლებიც არ იცვლება მათი შექმნის შემდეგ. ეს ნიშნავს, რომ, მაგალითად, რიცხვი ან სტრიქონი (string) პირდაპირ ვერ შეიცვლება.
- მუტაციური (Mutable) - მონაცემთა ტიპები(კომპლექსური), რომლებიც შეიძლება შეიცვალოს მათი შექმნის შემდეგ, მაგალითად, ობიექტები და მასივები.

```js
let number = 3; // Immutable
let str = "hello"; // Immutable
let bool = false; // Immutable

let obj = {
  number: 5,
};
obj.number = 10; // Mutable

let arr = [1, 2, 3];
arr.push(4); // Mutable
```

- რიცხვი, სტრიქონი, და ბულეანი არიან არამუტაციური ტიპები. მათთან მუშაობისას, თუ მნიშვნელობა შეიცვლება, ფაქტობრივად ახალი მონაცემი შეიქმნება მეხსიერებაში.
- ობიექტები და მასივები მუტაციური ტიპებია, ანუ მათი ცალკეული თვისებები ან ელემენტები შეიძლება შეიცვალოს ობიექტის ან მასივის შექმნის შემდეგ.

ამ მაგალითში, ობიექტის obj თვისება number შეიცვალა 5-დან 10-ზე, და მასივს arr დაემატა ახალი ელემენტი 4.

მუტაციის გაგება მნიშვნელოვანია კოდის ეფექტურობისთვის, რადგან მუტაციური ტიპების შეცვლა შესაძლებელია უშუალოდ, მაშინ როცა არამუტაციური ტიპების ცვლილება ქმნის ახალ მონაცემს.

## value vs reference

JavaScript-ში ცვლადების შედარებისას მნიშვნელოვანია გავარჩიოთ მნიშვნელობით(value) და მითითებით(reference) დამახასიათებელი ტიპები.

### value

მნიშვნელობით (Value) - პრიმიტიული ტიპები, როგორიცაა რიცხვები, სტრიქონები და ბულეანები, ინახება მნიშვნელობით. ეს ნიშნავს, რომ თუ ცვლადს მინიჭებული აქვს გარკვეული მნიშვნელობა, ის დამოუკიდებელია სხვა ცვლადებისგან, რომლებიც იმავე მნიშვნელობას ინახავენ.

```js
let number1 = 5;
let number2 = 5;
console.log(number1 === number2); // true
```

აქ number1 და number2 ინახავენ იმავე პრიმიტიულ მნიშვნელობას (5). მათი შედარებისას === ოპერატორი აბრუნებს true-ს, რადგან ორივე ცვლადში ერთსა და იმავე მნიშვნელობაა, თუმცა ისინი ცალ-ცალკე მეხსიერების ადგილას არიან დაცული.

მნიშვნელობით დამახასიათებელი ცვლადები ერთმანეთს არ ეკვრის მეხსიერების დონეზე, რაც ნიშნავს, რომ მათი შეცვლა გავლენას არ ახდენს სხვა ცვლადებზე.

### reference

მითითებით (Reference) მნიშვნელობა გამოიყენება იმ მონაცემთა ტიპებისთვის, რომლებიც მეხსიერებაში ინახება მისამართის დონეზე. ასეთი ტიპებია ობიექტები და მასივები. როდესაც ცვლადი მიმართავს ობიექტს ან მასივს, ის რეალურად ინახავს ამ მონაცემთა ადგილმდებარეობას მეხსიერებაში და არა უშუალოდ მის მნიშვნელობას.

```js
let obj1 = {
  number: 5,
};

let obj2 = {
  number: 5,
};

console.log(obj1 === obj2); // false
```

ამ შემთხვევაში, obj1 და obj2 ორივე შეიცავს number: 5, თუმცა მათი მეხსიერების მისამართები განსხვავებულია. შესაბამისად, obj1 === obj2 აბრუნებს false-ს, რადგან ისინი სხვადასხვა ობიექტზე მიანიშნებენ.

reference-ით დაკავსირებული ცვლადების მაგალითი:

```js
let obj1 = {
  name: "temo",
}; // 0x123

let obj2 = obj1; // 0x123

obj2.name = "nika";
console.log(obj1); // { name: "nika" }
```

- აქ obj1 და obj2 მიანიშნებენ ერთსა და იმავე ობიექტზე (მისამართი 0x123). შესაბამისად, როდესაც obj2-ს თვისება name იცვლება "nika"-ზე, იგივე ცვლილება აისახება obj1-შიც. ამის გამო console.log(obj1); გამოიტანს { name: "nika" }.

reference-ით მახასიათებელი მონაცემების შეცვლა შეიძლება გავლენას ახდენდეს სხვა ცვლადებზე, რომლებიც იმავე ობიექტზე ან მასივზე მიუთითებენ.

## მასივის დალუპვა (Looping an Array)

მრავალჯერადი ოპერაციების შესრულება მასივის ელემენტებზე შესაძლებელია ციკლების გამოყენებით, რაც ამარტივებს კოდს და თავიდან გვაცილებს თითოეული ელემენტის ცალკეულ წვდომას.

```js
let arr = [1, 2, 3, 4, 5];

console.log(arr[0]); // 1
console.log(arr[1]); // 2
console.log(arr[2]); // 3
console.log(arr[3]); // 4
console.log(arr[4]); // 5
```

ასეთი ჩანაწერი სწორია არაა, რადგან ერთი და იმავე კოდს ვწერთ, თან წინასწარ არ ვიცით, მასივში რამდენი ელემენტი შეიძლება იყოს.

ამის მაგივრად, ვიყენებთ ლუპებს.

```js
let arr = [1, 2, 3, 4, 5];

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
// შედეგი:
// 1
// 2
// 3
// 4
// 5
```

ეს for ციკლი ავტომატურად უვლის მასივის ყველა ელემენტს:

let i = 0; - ინიციალიზაცია: ციკლი იწყება პირველი ელემენტიდან, ანუ 0 ინდექსიდან (arr[0]).
i < arr.length; - პირობა: ციკლი გრძელდება მანამ, სანამ i არ მიაღწევს მასივის სიგრძეს.
i++ - ინკრემენტი: ყოველი იტერაციის შემდეგ, i იზრდება 1-ით.
შედეგად, ყოველ იტერაციაზე arr[i] დაბეჭდავს შესაბამის ელემენტს.

ასეთი ციკლები მასივებთან მუშაობას უფრო ეფექტურს ხდის, რადგან ისინი ავტომატურად გადიან ყველა ელემენტს, რაც გამორიცხავს ხელით წვდომის საჭიროებას.

## for of Looping

JavaScript-ში მასივის ელემენტებზე გასავლელად შეგვიძლია გამოვიყენოთ for...of ციკლი, რომელიც საშუალებას გვაძლევს მარტივად მოვახდინოთ ყველა ელემენტზე წვდომა ცალკეული ინდექსის მითითების გარეშე.

```js
let arr = [1, 2, 3, 4, 5];

for (let number of arr) {
  console.log(number);
}

// შედეგი:
// 1
// 2
// 3
// 4
// 5
```

აქ for...of ციკლი ავტომატურად იღებს თითოეულ ელემენტს arr მასივიდან და ანიჭებს მას number ცვლადს(ამ ცვლადს რასაც გვინდა იმას დავარქმევთ). შემდეგ კი, console.log(number); დაბეჭდავს თითოეულ ელემენტს.

ეს ხერხი უფრომოსახერხებელია, რადგან თავიდან გვაცილებს ინდექსის გამოყენების საჭიროებას.

## More Array Methods

JavaScript-ში მასივებთან მუშაობისთვის არსებობს მრავალი სასარგებლო მეთოდი. აქ მოცემულია რამდენიმე ყველაზე ხშირად გამოყენებადი:

1. includes() - ამოწმებს, არსებობს თუ არა მოცემული ელემენტი მასივში, და აბრუნებს true ან false მნიშვნელობას.

```js
let arr = [1, 2, 3, 4, 5];
console.log(arr.includes(3)); // true
console.log(arr.includes(6)); // false
```

2. indexOf() - აბრუნებს ელემენტის პირველ ინდექსს, თუ ის არსებობს მასივში. თუ ელემენტი არ არსებობს, აბრუნებს -1

```js
let arr = [1, 2, 3, 4, 5];
console.log(arr.indexOf(3)); // 2
console.log(arr.indexOf(6)); // -1
```

3. lastIndexOf() - ეძებს ელემენტს მასივის ბოლოსკენ და აბრუნებს მის ინდექსს. თუ ელემენტი არ არსებობს, აბრუნებს -1.

```js
let arr = [1, 2, 3, 4, 3, 5];
console.log(arr.lastIndexOf(3)); // 4
```

4. slice() - ქმნის ახალ მასივს, რომელიც შეიცავს მოცემული მასივის ნაწილს. იღებს ორ არგუმენტს: დასაწყისის და დასასრულის ინდექსებს - საიდან სადამდე უნდა ამოიჭრას მასივი.

```js
let arr = [1, 2, 3, 4, 5];
let sliced = arr.slice(1, 4);
console.log(sliced); // [2, 3, 4]
```

5. splice() - შლის ელემენტებს მასივიდან(ახდენს ორიგინალი მასივის მუტაციას) და/ან ამატებს ახალ ელემენტებს მითითებულ პოზიციაზე. პირველი არგუმენტი არის დასაწყისის ინდექსი, მეორე - რამდენი ელემენტი უნდა წაიშალოს და დანარჩენი არგუმენტები - ახალი ელემენტები მასივში დასამატებლად.

```js
let arr = [1, 2, 3, 4, 5];
arr.splice(2, 1, "new");
console.log(arr); // [1, 2, "new", 4, 5]
```

6. toSpliced() - toSpliced() არის ახალი მეთოდი, რომელიც splice()-ს მსგავსად მუშაობს, თუმცა ქმნის მასივის ასლს ცვლილებების გარეშე და არ ცვლის თავდაპირველ მასივს. იგი ქმნის ახალ მასივს, სადაც შესრულებულია splice() ოპერაცია.

toSpliced() იღებს ორ ძირითად პარამეტრს: დასაწყისის ინდექსს და წასაშლელ ელემენტთა რაოდენობას. დამატებით, მას შეუძლია მიიღოს ახალი ელემენტებიც, რომლებიც ჩაჯდება მასივში.

```js
let arr = [1, 2, 3, 4, 5];
let newArr = arr.toSpliced(2, 1, "new");

console.log(arr); // [1, 2, 3, 4, 5]
console.log(newArr); // [1, 2, "new", 4, 5]
```

- ამ მაგალითში, toSpliced() ფუნქცია არ ცვლის ორიგინალ arr მასივს.
- newArr შეიცავს ახალ ელემენტს "new" მასივის მესამე ადგილზე (ინდექსი 2) და ინახავს მასივის შეცვლილ ვერსიას.

toSpliced() ძალიან მოსახერხებელია, როცა საჭიროა არსებული მასივის შენარჩუნება და მხოლოდ მისი ასლის ცვლილება.
