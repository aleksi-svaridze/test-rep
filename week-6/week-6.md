# Higher Order Functions | მაღალი დონის ფუნქციები

Higher-Order Functions (HOFs) არიან ფუნქციები, რომლებიც ან იღებენ სხვა ფუნქციას არგუმენტად, ან აბრუნებენ ფუნქციას შედეგად. ეს მიდგომა ჩვენს პროგრამას უფრო მოკლეს და გასაგებს ხდის. ჩვენც ზუსტად ამას უნდა ვციდლობდეთ - სულაც არაა მაგარი, როცა პროგრამის შესაქმნელად ტყუილად ვწერთ ბევრ კოდს, არსებობს მისი შემოკლების მრავალი გზა. ერთ-ერთს ამ თავში ვისწავლით.

## დიდი პროგრამა == მეტი ბაგი

ამ კოდში ნაჩვენებია ორი სხვადასხვა გზა, თუ როგორ შეიძლება 1-დან 10-მდე რიცხვების შეკრება.

1. პირველი ხერხი (პირდაპირი while ციკლით):

```js
let total = 0,
  count = 1;
while (count <= 10) {
  total += count;
  count += 1;
}
console.log(total);
```

- ეს პროგრამა იყენებს `while` ციკლს და ყოველ ჯერზე 1-დან 10-მდე ცვლადი `count` ზრდის `total`-ის მნიშვნელობას. შედეგი არის `total = 55`.

2. მეორე ხერხი (ფუნქციებით):

```js
function sum(arr) {
  let sum = 0;
  for (let number of arr) {
    sum += number;
  }
  return sum;
}

function range(start, end) {
  let arr = [];
  for (let i = start; i <= end; i++) {
    arr.push(i);
  }
  return arr;
}

console.log(sum(range(1, 10)));
```

- აქ გამოყენებულია ორი ფუნქცია:

  - `range` - ქმნის მასივს, რომელიც შეიცავს 1-დან 10-ის ჩათვლით რიცხვებს
  - `sum` - იღებს მასივს და აბრუნებს მასში რიცხვების ჯამს.

- საბოლოოდ, `console.log(sum(range(1, 10)));` ბეჭდავს 55-ს, რომლის პასუხიც `while` ციკლის კოდთან იდენტურია.

### შედარება და ანალიზი:

- პირდაპირი `while`ციკლი: ნაკლები კოდი, მაგრამ ნაკლებად მოქნილი - ეს პროგრამა, მხოლოდ 1-დან 10-ის ჩათვლით რიცხვებზე იმუშავებს
- ფუქნციები (`sum` და `range`): მეტი კოდი, მაგრამ მეტი მოქნილობა - აპ პროგრამას იმ რიცხვებზე ვამუშავებთ, რომლებზეც ჩვენ მოგვესურვება. მიუხედავად იმისა, რომ უფრო მეტი კოდი გვიწერია, ფუქნციები ერთხელ შევქმენით და გავტესტეთ და ამის მერე გამოვიყენებთ იმდენჯერ, რამდენჯერაც დაგვჭირდება და ამ დროს უკვე უშუალოდ ფუნქციების შიგთავსზე აღარ ვიფიქრებთ. გამოდის, რომ ფუქნციებს ერთხელ შევქმნით და შემდგომ მათ აბსტრაქციებად გამოვიყენებთ. ეს მიდგომა კოდში ბაგების არსებობის ალბათობას ამცირებს.

## აბსტრაქცია

აბსტრაქცია გვეხმარება კომპლექსური პროცესების მარტივ და გასაგებ მითითებებში დაყვანაში. წინა მაგალითის მსგავსად, ჯობია პროგრამაში გვქონდეს ზოგადი ფუქნციები, რომლებიც ერთხელ დაიწერება და გაიტესტება და შემდგომ გამოვიყენებთ მათ როგორც აბსტრაქციებს. ჩვენს წერისას და სხვებსაც კოდის კითხვისას არ მოგვიწევს ფუნქციების კოდის ახლიდან გარჩევა, მხოლოდ მათ გამოძხებებს დავაკვირდებით და ისე გავიგებთ, თუ რას აკეთებს მოცემული ფუნქცია.

მაგალითისთვის მოვიყვანოთ მანქანის დაქოქვა. ვიღაცამ ჩვენი მანქანა ააწყო, გატესტა რომ მუშაობს და იქოქება, ხოლო ჩვენ მანქანის დაქოქვისას აღარ ვფიქრობთ იმაზე, თუ რა ნაწილებისგან შედგება მანქანა ან რა პროცესები მიმდინარეობს ძრავაში მანქანის დაქოქვისას. დაქოქვა ჩვენთვის უკვე არის აბსტრაქცია.

ეს მაგალითი გვიჩვენებს, თუ როგორ შეგვიძლია აბსტრაქციის გამოყენება კოდის გამარტივების და გამეორების შემცირების მიზნით. repeat ფუნქცია კოდს უფრო მოქნილს ხდის და ხელახალი გამოყენების საშუალებას აძლევს.

1. საწყისი `for` ციკლი:

```js
for (let i = 0; i < 10; i++) {
  console.log(i);
}
```

ეს პროგრამა მხოლოდ 0დან 10-მდე რიცხვებს გამოაკონსოლებს. ანუ გაიმეორებს კონსოლი ფუქნციას 10-ჯერ. ორივე მითითება კონკრეტულია - რა უნდა გააკეთოს და რამდენჯერ უნდა გააკეთოს. რომ მოგვინდეს სხვა რამის გაკეთება ან სხვა რაოდენობით გაკეთება, მოგვიწევს მსგავსი კოდის ხელახლა დაწერა.

2. ფუნქციის შექმნა განმეორებადი ლოგიკისთვის:

```js
function repeatLog(n) {
  for (let i = 0; i < n; i++) {
    console.log(i);
  }
}
```

- `repeatLog` უკვე უკეთესი გადაწყვეტილებაა. ის საშუალებას გვაძლევს, განვსაზღვროთ, რამდენჯერ უნდა დაიბეჭდოს `i`(n პარამეტრის ხარჯზე), რაც ფუნქციის გამოყენების მოქნილობას ზრდის.
- თუმცა, ეს ფუნქცია მაინც შეზღუდულია და მხოლოდ `console.log` ფუნქციას იყენებს.

3. ზოგადი ფუნქცია `repeat` - სრულად აბსტრაქტული მიდგომა:

```js
function repeat(n, action) {
  for (let i = 0; i < n; i++) {
    action(i);
  }
}

repeat(5, console.log);
```

- აქ `repeat` იღებს ორ არგუმენტს: რაოდენობა `n` და `action` ფუნქცია, რომელიც ციკლის თითოეულ იტერაციაზე უნდა შესრულდეს. `repeat` მაღალი დონის ფუნქციაა, რადგან თავადაც ფუნქციაა და პარამეტრადაც სხვა ფუქნციას იღებს.
  ამ მაგალითში `repeat` ფუნქციას არგუმენტად ვატანთ `console.log`-ს. ოღონდ მანდვე არ ვიძახებთ და მრგვალ ფრჩხილებს არ ვუწერთ. არგუმენტი შეინახება `action` პარამეტრში, რომელსაც გამოვიძახებთ `for` ციკლში.

კიდევ ერთი მაგალითი:

```js
let labels = [];
repeat(5, (i) => {
  labels.push(`Unit ${i + 1}`);
});
console.log(labels);
// → ["Unit 1", "Unit 2", "Unit 3", "Unit 4", "Unit 5"]
```

`repeat` ფუნქციით 5-ჯერ ვიმეორებთ მასივში ელემენტების დამატების ფუნქციონალს. ფუნქციებს, რომლებსაც სხვა ფუქნციებს არგუმენტად გადავცემთ, `callback` ფუქნციები ეწოდებათ.

## Callback Functions

`Callback` ფუნქციები გამოიძახება იმ ფუნქციებში, რომელსაც ვატანთ არგუმენტად მას. მაგალითად:

```js
function foo(a, b, callback) {
  if (a > b) {
    callback(); // მხოლოდ მაშინ იძახებს callback-ს, თუ a > b
  }
}

foo(10, 5, () => console.log("invoked"));
```

აქ `callback` არის ფუნქცია, რომელიც არგუმენტად გადაეცემა `foo`-ს და შემდგომ ხდება მისი გამოძახება, თუ პირობა `a > b` ჭეშმარიტი იქნება.

1. `foo` ფუნქციის გამოძახება - `foo(10, 5, () => console.log("invoked"))`
   გამოძხება:
   _ `a = 10`
   _ `b = 5` \* `callback = () => console.log("invoked")`
2. პირობის შემოწმება:
   `foo` ფუნქცია ამოწმებს პირობას `if (a > b)`, ანუ თუ a მეტია დიდია, ვიდრე b. ამ შემთხვევაში, 10 > 5, ამიტომ პირობა ჭეშმარიტია.
3. Callback ფუნქციის გამოძახება:
   პირობა შესრულდა, ამიტომ `callback()` გამოიძახება, რაც ასრულებს `() => console.log("invoked")` ფუნქციას და დაბეჭდავს:

```js
invoked;
```

`Callback` ფუნქცია არის ფუნქცია, რომელიც გადაეცემა სხვა ფუნქციას არგუმენტად, რათა შემდგომში საჭირო დროს გამოიძახოს ის. ამ შემთხვევაში, `callback` გამოიძახება მხოლოდ იმ შემთხვევაში, თუ `a` უფრო დიდია, ვიდრე `b`.

## Filtering Arrays | მასივების გაფილტრვა

ქვევით მოცემულია სამი სხვადასხვა მიდგომა მასივის გასაფილტრად. თითოეული მათგანი უზრუნველყოფს ერთი და იმავე ფუნქციონალს სხვადასხვა აბსტრაქციის დონის გამოყენებით. მოდით განვიხილოთ თითოეული

1. პირველადი `filter` ფუნქცია:

```js
function filter(array) {
  let passed = [];

  for (let element of array) {
    if (element % 2 === 0) {
      passed.push(element);
    }
  }

  return passed;
}
```

- ეს ფუნქცია გადის `array`-ს თითოეულ ელემენტზე და ამატებს passed მასივში მხოლოდ იმ ელემენტებს, რომლებიც 2-ზე გაყოფისას ნაშთს აბრუნებენ 0-ს (ლუწი რიცხვებია).
- თუმცა, ეს ფუნქცია შეზღუდულია, რადგან მხოლოდ ლუწი რიცხვების გაფილტვრა შეუძლია.

2. `filter` ფუნქცია, რომელიც იღებს `test` ფუნქციას პარამეტრად.

```js
function filter(array, test) {
  let passed = [];

  for (let element of array) {
    if (test(element)) {
      passed.push(element);
    }
  }

  return passed;
}
```

- ამ ვერსიაში `filter` იღებს `test` ფუნქციას მეორე არგუმენტად, რაც საშუალებას გვაძლევს გამოვიყენოთ სხვადასხვა პირობები ელემენტების ფილტრაციისთვის.
- `test(element)` ფუნქციას ვიღებთ როგორც არგუმენტს, რაც კოდს უფრო მოქნილს ხდის, რადგან შეგვიძლი test-ის პირობაში ჩავსვათ ნებისმიერი პირობა.

3. `filter` მეთოდის გამოყენება

```js
const filteredArr = arr.filter((element) => element % 2 === 0);
```

- ეს არის JavaScript-ის ჩაშენებული `filter` მეთოდი, რომელიც ყველაზე მარტივია და პირდაპირ ფილტრავს მასვის.
- `arr.filter()` მეთოდი იღებს ფუნქციას, რომელიც შეამოწმებს თითოეულ ელემენტს, და მხოლოდ შესაბამის ელემენტებს დატოვებს ახალ მასივში, ამ შემთხვევისთვის კი დატოვებს მხოლოდ ლუწ რიცხვებს. არგუმენტად გადაცემული ფუქნციის პირველი პარამეტრი(element) არის ამჟამინდელი რიცხვი მასივში, ანუ ჯერ პირველი ელემენტი, მერე მეორე, შემდეგ მესამე და ა.შ. `filter` მეთოდის უკან სინამდვილეში `for` ციკლი დგას.

### შეჯამება:

- პირველი ფუნქცია — სპეციალიზებულია მხოლოდ ლუწი რიცხვებისთვის.
- მეორე ფუნქცია — განზოგადებული, რათა ნებისმიერი პირობით გაატაროს ფილტრაცია, რაც საშუალებას აძლევს, იყოს მეტად მოქნილი.
- ჩაშენებული `.filter()` მეთოდი — ყველაზე მარტივი და ხარჯავს ნაკლებ რესურსს. ის აბრუნებს ახალ მასივს, სადაც არის ფილტრაციის შემდგომ დარჩენილი ელემენტები. ანუ არ ხდება ორიგინალი მასივის მუტაცია.

მეორე და მესამე მიდგომა საუკეთესოა ხელახალი გამოყენებისა და კოდის სისუფთავის მხრივ, ხოლო ჩაშენებული .filter() მეთოდი იდეალურია მოკლე და მარტივი კოდის დასაწერად.

## მსივების ტრანფორმაცია | დამაპვა

ქვევით ნაჩვენებია სამი გზა მასივის ტრანსფორმაციისთვის, რომლებიც უზრუნველყოფენ ელემენტების დამუშავებას ერთსა და იმავე პრინციპით: მასივის თითოეული ელემენტი გამრავლებულია 2-ზე. მოდით, განვიხილოთ თითოეული მიდგომა.

1. ტრადიციული `for` ციკლის გამოყენება.

```js
let arr = [1, 2, 3, 4, 5];
let tranformedArr = [];

for (let i = 0; i < arr.length; i++) {
  tranformedArr[i] = arr[i] * 2;
}
```

- ეს არის ყველაზე ძირითადი ფორმა: for ციკლი გადის მასივის თითოეულ ელემენტს და შეინახავს მას `tranformedArr` მასივის შესაბამის ინდექსზე.

* ეს მიდგომა ეფექტურია, მაგრამ უფრო შრომატევადი და მოითხოვს კოდის მეტ წერას.

2. ზოგადი `map` ფუქნცია:

```js
function map(array, transform) {
  let mapped = [];
  for (let element of array) {
    mapped.push(transform(element));
  }
  return mapped;
}
```

- ამ ვერსიაში, ჩვენმა map ფუნქციამ მიიღო არგუმენტად მასივი და `transform` ფუნქცია, რომელიც განსაზღვრავს, თუ რა ტრანსფორმაცია უნდა გაიაროს მასივის თითოეულმა ელემენტმა.

- `transform` ფუნქცია წვდომას მიიღებს ელემენტზე და შეასრულებს მასზე მოქმედებას.
- ამ შემთხვევაში, `map` ფუნქცია შეგვიძლია გამოვიყენოთ სხვა შემთხვევებშიც.

3. ჩაშენებული `map` მეთოდის გამოყენება:

```js
let changedArr = arr.map((element) => element * 2);
```

ეს არის JavaScript-ში ჩაშენებული `map` მეთოდი, რომელიც იღებს ფუნქციას არგუმენტად. ის პირდაპირ ქმნის ახალ მასივს, რომელშიც ყველა ელემენტი იქნება წინაზე 2-ჯერ მეტი.

- `.map()` არის უფრო მოკლე და გასაგები, რადგან პირდაპირ მუშაობს მასივთან და ამუშავებს ყველა ელემენტს. ის აბრუნებს ახალ მასივს, სადაც უკვე სახეშეცვლილი ელემენტები არიან, ანუ არ ახდენს ორიგინალი მასივის მუტაციას.

## sort() მეთოდი

JavaScript-ის sort() მეთოდი გამოიყენება მასივის ელემენტების დასალაგებლად და არსებულ მასივს ალაგებს ალფაბეტური ან მომხმარებლის მიერ განსაზღვრული კრიტერიუმით. მოდით, განვიხილოთ მისი მუშაობის პრინციპები და გამოყენების მაგალითები.

1. `sort()` მეთოდის ალფაბეტური ლოგიკა.

უბრალოდ `sort()` მეთოდი არგუმეტნის გადაცემის გარეშე მასივს ალაგებს ალფაბეტის მიხედვით:

```js
let fruits = ["banana", "apple", "cherry"];
fruits.sort();
console.log(fruits);
// შედეგი: ["apple", "banana", "cherry"]
```

2. რიცხვების სორტირება (ზრდადობის მიხედვით)

რიცხვების სორტირებისას sort()-ის ალფაბეტური სორტირების ლოგიკა იწვევს შეცდომას, რადგან 10 უფრო წინ დადგება ვიდრე 2, რადგან ალფაბეტურად ეს ასეცაა. ამის თავიდან ასაცილებლად უნდა გამოვიყენოთ ფუნქცია, რომელიც განსაზღვრავს, თუ როგორ უნდა შედარდეს ელემენტები:

```js
let numbers = [10, 5, 20, 2, 15];
numbers.sort((a, b) => a - b); // ზრდადობის მიხედვით სორტირება
console.log(numbers);
// შედეგი: [2, 5, 10, 15, 20]
```

`sort` მეთოდისთვის გადაცემული ფუნქციის პარამეტრები `a` და `b` არიან მეზობელი რიცხვები. მათი გამოკლების შემდეგ მიიღება დადებითი, უარყოფითი პასუხი, ან სულაც 0. თუ დადებითი პასუხი მივიღეთ, `sort` მეთოდი ამ ორ რიცხვს ადგილებს გაუცვლის, სხვა შემთხვევებში ხელუხლებელს დატოვებს და სხვა მეზობელ რიცხვებზე გადავა.

## forEach

`forEach` გამოიყენება მასივების დასალუპად და თითოეული ელემენტისთვის კონკრეტული ფუნქციონალის გასატარებლად. მისთვის არგუმენტად გადაცემული პარამეტრების ლოგიკური მნიშვნელობებია - `currentValue`(ამჟამინდელი მნიშვნელობა), `index`(ამჟამინდელი ელემენტის ინდექსი), `array`(ის მასივი, რომელსაც დავადეთ forEach მეთოდი):

```js
let fruits = ["apple", "banana", "cherry"];

fruits.forEach((fruit, index, array) => {
  console.log(`${index}: ${fruit} - arr: ${array}`);
});
// შედეგი:
// 0: apple - arr: ["apple", "banana", "cherry"]
// 1: banana - arr: ["apple", "banana", "cherry"]
// 2: cherry - arr: ["apple", "banana", "cherry"]
```

## P.S

აუცილებლად ცაიკითხეთ MDN-ზე თითოეული მეთოდის უფრო დეტალური განხილვა, ასევე გაეცანით ყველა პარამეტრის ლოგიკურ მნიშვნელობას.
